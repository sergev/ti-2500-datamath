// TI calculator simulator
// Ken Shirriff, http://righto.com/ti
// Based on patent US3934233
// Code transcribed by Phil Mainwaring
//
// This file holds the source and object code to be executed.

var sourceCode = [
  "0   START    ZFA    ALL ; init - clear flags",
  "1            ZFB    ALL",
  "2            AKA    ALL ; clear A and C",
  "3            AKC    ALL",
  "; For display, A's MANT starts in digit 5. For computation, MANT starts in digit 6",
  "; C holds the previous value, with MANT starting in digit 6. Digit 5 counts inputted digits",
  "4   MAINLOOP SLLA   MANT ; Shift mantissa for display",
  "5            AKB    ALL ; clear B",
  "6   WAITSCAN SYNC ; loop until no key pressed",
  "7            SCAN",
  "8            BINE   WAITSCAN",
  "9   WAITKEY  WAITNO WAITED ; wait for key",
  "10  WAITED2  SYNC ; debounce: still pressed?",
  "11           SCAN",
  "12           BIE    WAITKEY ; loop if no key",
  "13           SYNC",
  "14           SRLA   MANT ; MANT is shifted right during calculation",
  "15           BKO    LOWERKEY ; sequentially scan key columns",
  "16           BKO    PLUSKEY",
  "17           BKO    MINUSKEY",
  "18           BKO    DIVKEY",
  "19           BKO    MULTKEY",
  "20           BKO    UPPERKEY",
  "21           BKO    EKEY",
  "22           BKO    ZEROKEY",
  "23           EXAB   ALL ; save A in B, A=0",
  "24           AKCN   DIGIT1 ; get digit by incrementing until column found",
  "25           EXAB   ALL ; restore A, B holds count",
  "26           BINE   MAINLOOP ; start over if nothing pressed",
  "27  ZEROKEY  TFB    EMODE ; B holds key 0-9",
  "28           BINE   EDIGIT",
  "; If OPDONE, a digit starts a new number in A, leaving the previous in C",
  "29           TFB    OPDONE ; if OPDONE...",
  "30           BIE    LABEL33",
  "31           AKA    ALL ; then clear A and OPDONE",
  "32           ZFB    OPDONE",
  "33  LABEL33  ACKA   DIGIT ; C holds digit position",
  "34  BSHIFT   SRLB   ALL ; shift B right C times.",
  "35           SAKA   DIGIT1 ; decrement A",
  "36           BIE    BSHIFT ; (no borrow)",
  "37           ACKC   DIGIT1 ; increment digit count in C",
  "38           AABA   MANT ; Append new digit",
  "39           BIE    MAINLOOP ; done digit processing",
  "40  EDIGIT   ZFB    NEWEXP ; clear new exponent flag",
  "41           SLLA   EXP ; shift exponent left",
  "42           SLLB   ALL ; shift digit left",
  "43           AABA   EXP ; append new digit to exponent",
  "44           BIE    MAINLOOP ; done",
  "45  EKEY     SFB    EMODE ; entering exponent mode",
  "46           SFB    NEWEXP",
  "47           BIE    MAINLOOP ; done",
  "48  LOWERKEY SFA    LOW ; LOW and UP_LOW set for LOWER key",
  "49  UPPERKEY SFA    UP_LOW ; UP_LOW set for UPPER key",
  "50           BIE    MAINLOOP ; done",
  "51  MINUSKEY TFA    UP_LOW ; alt-MINUS is COS",
  "52           BINE   COSKEY",
  "; Minus normally is just addition after negating A.",
  "; Except - following E changes the exponent sign instead.",
  "; Except a second minus following E - does a subtraction",
  "53           TFB    NEWEXP ; - follows E?",
  "54           BIE    DOSUBTR",
  "55           AAKA   EXP_S5 ; negate exponent for E - keystrokes",
  "56           BIE    MAINLOOP ; if already neg, fall through subtract",
  "57  DOSUBTR  AAKA   MANT_S5 ; negate mantissa then fall through and add",
  "58           BIE    PLUSKEY ; clear condition flag",
  "59  PLUSKEY  TFA    UP_LOW ; alt-PLUS is SIN",
  "60           BINE   SINKEY",
  "; Add A and C. First, C is copied to B. The numbers need to have equal",
  "; exponents to be added so the difference in exponents is ",
  "; computed using C and B is shifted left to align the mantissas.",
  "; If the mantissas have different signs, they are subtracted instead of added,",
  "; which may require A and B to be swapped.",
  "61  ADDSUB   AKC    DIGIT ; Clear C DIGIT",
  "62           ACKB   ALL ; copy C to B",
  "63           ABAC   EXP ; add exponents into C",
  "64           BIE    CLRCC ; Clear condition code",
  "65  CLRCC    ABAC   EXP_S5 ; add exponent signs",
  "66           SCKC   EXP_S5 ; subtract 5 from sign",
  "67           BIE    EXPSNES ; signs were different",
  "68           CAB    EXP ; compare exponents",
  "69           BIE    EXPAGE ; branch >=",
  "70           EXAB   ALL ; switch arguments so A EXP > B EXP",
  "71  EXPAGE   SABC   EXP ; same sign - subtract exponents into C",
  "72  EXPSNES  CAK    EXP_S5 ; Test A exponent sign",
  "73           BINE   AEXPPOS ; branch on borrow, A exp sign == 0",
  "74           EXAB   ALL ; switch arguments so A EXP > B EXP",
  "75  AEXPPOS  CAK    MANT1 ; make sure A is nonzero",
  "76           BIE    BSHIFT2",
  "77           EXAB   ALL",
  "78  BSHIFT2  SCKC   EXP1 ; shift B by difference in exponents (C) to line up",
  "79           BINE   DONE2",
  "80           SRLB   MANT",
  "81           BIE    BSHIFT2 ; branch every time",
  "82  DONE2    ABAC   MANT_S5 ; add mantissa signs and subtract 5",
  "83           SCKC   MANT_S5",
  "84           BIE    SUBMANT ; signs different",
  "85  TRYADD   AABA   MANT ; add mantissas, or restore A if did SUBMANT",
  "86           BIE    NORMLIZE ; branch if no overflow, i.e. did add",
  "87           EXAB   MANT ; failed subtract: swap A and B and try again.",
  "88           EXAB   MANT_S5",
  "; Try subtracting mantissas: A-B. If B>A, add B back, swap, and try again",
  "89  SUBMANT  SABA   MANT ; subtract mantissa",
  "90           BINE   TRYADD ; A was smaller than B: try again",
  "91           BIE    NORMLIZE ; branch every time, done",
  "; Multiplication: add exponents with different signs",
  "92  SIGNSNE  CAB    EXP ; compare EXP magnitudes",
  "93           BIE    SUBEXPS ; branch if |A| >= |B|",
  "94           EXAB   EXPSGNS1 ; swap exponents and signs",
  "; At this point, |A| >= |B|, so can subtract and A's sign won't change",
  "95  SUBEXPS  SABA   EXP ; subtract EXPs",
  "96           BIE    EXPSDONE ; branch every time",
  "; Division entry point: compute C / A.",
  "; First, normalize A mantissa since repeatedly subtracting A depends on",
  "; having A normalized. Next, use multiply's add-exponent code to subtract",
  "; A's exponent from C's.",
  "; The DIVLOOP loop repeatedly subtracts B from C, counting into A.",
  "; Successive loops shift by 10 to perform long division.",
  "97  DIVKEY   TFA    UP_LOW ; entry point for DIV",
  "98           BINE   TANKEY ; alt-DIV is TAN",
  "99           SFA    COS_TAN ; reusing flag to indicate division",
  "100 DODIV    SFA    RET1FLAG ; 'subroutine call' flag",
  "101          BIE    NORMLIZE ; 'Subroutine call' to normalize A",
  "102 RET1     ZFA    RET1FLAG ; 'Return' here after NORMLIZE",
  "103          AAKA   EXP_S5 ; toggle A's EXP sign since dividing not multiplying",
  "104          BIE    MULTKEY ; clear cc",
  "; Multiply by adding exponents and multiplying mantissas",
  "; If COS_TAN set, divide by adding exponents, then jump to DIVMANT",
  "; i.e. the code to add exponents is reused for division",
  "105 MULTKEY  TFA    UP_LOW ; alt-MULT is LOG",
  "106          BINE   LOGKEY",
  "107          AKC    DIGIT ; clear entered digit count",
  "108          ACKB   ALL ; copy C to B",
  "109          EXAB   MANT",
  "; Add exponents; tricky if signs are different",
  "110          ABAC   EXP_S5",
  "111          SCKC   EXP_S5",
  "112          BIE    SIGNSNE ; if signs different, use SIGNSNE",
  "113          AABA   EXP ; simply add exponents",
  "114 EXPSDONE AABA   MANT_S5 ; xor signs",
  "115          BIE    CLRCC2 ; clear before test",
  "116 CLRCC2   TFA    COS_TAN ; set if dividing",
  "; Compute A = B * C mantissas; EXP already computed",
  "117 MULTMANT AKA    MANT ; clear mantissa",
  "118          BINE   DIVMANT ; branch if dividing",
  "119 MLTLOOP1 SRLA   MANT ; multiply B * C",
  "120 MLTLOOP2 CCK    MANTLOW1 ; Add B to A, repeat low digit of C times",
  "121          BINE   MULTSHFT",
  "122          SCKC   MANT1",
  "123          AABA   MANT",
  "124          BIE    MLTLOOP2",
  "125 MULTSHFT SRLC   MANT ; shift C right",
  "126          CCK    MANT1",
  "127          BIE    MLTLOOP1 ; loop if not done",
  "128          TFA    LOW",
  "129          BINE   ALOGRET ; Return to ALOGRET if LOW flag set (ANTILOG)",
  "; Normalizes mantissa by removing leading zeros.",
  "; This is called to finish up after an operation",
  "; Also subroutine call; RET1FLAG will cause return to RET1",
  "130 NORMLIZE CAK    MANT1 ; Test if mantissa is < 1",
  "131          BINE   START ; if mantissa is 0, reset",
  "; Repeatedly shift MANT left until a value in the 5 digit.",
  "; Decrement EXP each step to compensate",
  "132 MANTSHL  CAK    DIGIT1 ; Loop to left-align mantissa",
  "133          BIE    MANTOK ; Branch if mantissa aligned",
  "134          SLLA   MANT ; Shift mantissa left",
  "; Decrementing the exponent is a bit tricky because sign is separate",
  "; Cases are: positive exponent, exponent becoming -1, and negative exponent",
  "135          CAK    EXP_S5 ; Check exponent sign",
  "136          BIE    EXPNEG ; Branch if negative",
  "137          SAKA   EXP1 ; Decrement exponent",
  "138          BIE    EXPPOS3 ; Branch if no borrow",
  "139          AKA    EXP_S5 ; EXP went negative: Set exponent sign",
  "140          AKA    EXP1 ; Set exponent to 1",
  "141 EXPPOS3  SAKA   EXP1 ; Decrement exponent to cancel next instruction ",
  "142 EXPNEG   AAKA   EXP1 ; For negative exponent, inc EXP to decrement",
  "143          BIE    MANTSHL ; two branches to clear condition flag",
  "144          BIE    MANTSHL",
  "; At this point, mantissa is left-aligned into digit 5",
  "; Now shift one position right and increment exponent, taking sign into account",
  "145 MANTOK   SRLA   MANT",
  "146          CAK    EXP_S5 ; Test exponent sign",
  "147          BINE   EXPPOS",
  "148          SAKA   EXP1 ; Decrement exponent",
  "149          SAKA   EXP1 ; Decrement exponent",
  "150 EXPPOS   AAKA   EXP1 ; Increment exponent",
  "151          BIE    CLRCC1 ; clear condition",
  "152 CLRCC1   TFA    RET1FLAG ; Subroutine return",
  "153          BINE   RET1 ; return to RET1 if RET1FLAG set",
  "; returned if RET1FLAG set, otherwise clean up...",
  "; clear B, set OPDONE, clear A flags, fix EXP sign, copy A result to C",
  "154          ZFB    ALL ; Clear B",
  "155          SFB    OPDONE ; Set op done flag?",
  "156          ZFA    ALL ; Clear A flags",
  "; Fix EXP of -00 if necessary",
  "157          CAK    EXP1 ; Is exponent zero (< 1)",
  "158          BIE    EXPPOS2",
  "159 CLEARSGN AAKA   EXP_S5 ; Flip sign",
  "160          BIE    CLEARSGN ; Branch if sign was clear before",
  "161 EXPPOS2  AAKC   ALL ; Copy A to C",
  "162          BIE    MAINLOOP ; BET",
  "; Entry points for TAN, COS, and SIN",
  "163 TANKEY   SFA    TAN",
  "164 COSKEY   SFA    COS_TAN",
  "165 SINKEY   SAKA   EXP1 ; shift mantissa by exponent",
  "166          BINE   DONESHFT",
  "167          SRLA   MANT",
  "168          BIE    SINKEY",
  "169 DONESHFT AKA    EXPSGNS1 ; clear signs",
  "170          SAKA   EXPSGNS1 ; EXP = 0",
  "171          AKC    ALL ; clear C",
  "172          TFA    LOW ; check for ARC-",
  "173          BIE    NORMOP ; branch if no",
  "174          TFA    TAN ; check ARCTAN?",
  "175          BIE    ASINCOS ; branch if no",
  "176          AAKC   ALL ; ARCTAN: copy A to C",
  "177          AKB    MASKA1 ; set digit in B",
  "178          BIE    TRGLOOP2 ; branch every time",
  "179 ASINCOS  AAKA   MANTD1",
  "180 NORMOP   AKB    MANTD5 ; B = .0005 (current SIN)",
  "181          SRLB   MANT",
  "182          ACKC   MASKA1 ; C += 1 (current COS)",
  "; Loop test for SIN/COS/TAN",
  "183 TRIGLOOP SAKA   MANTD1 ; rotate A times, by .001 rad",
  "184          BINE   TRIGDONE ; branch on borrow - done",
  "; The main trig loop. B holds sin, C holds cos.",
  "; The loop is performed A times, rotating by .001 rad each time.",
  "185 TRGLOOP2 SLLC   ALL ; shift C to prepare for add",
  "186          SLLC   ALL",
  "187          SLLC   ALL",
  "188          ACKC   MANTD5 ; C=C-B/1000 (rounded)",
  "189          SCBC   ALL",
  "190          SRLC   ALL ; restore C",
  "191          SRLC   ALL",
  "192          SRLC   ALL",
  "193          SLLB   ALL ; shift B to prepare for add",
  "194          SLLB   ALL",
  "195          SLLB   ALL",
  "196          ACKC   MANTD5 ; B=B+C/1000 (rounded)",
  "197          ABCB   ALL",
  "198          SCKC   MANTD5 ; restore C",
  "199          SRLB   ALL",
  "200          SRLB   ALL",
  "201          SRLB   ALL",
  "202          TFA    LOW ; ARC-op?",
  "203          BIE    TRIGLOOP ; no: branch",
  "; Increment ARC-trig count, check termination",
  "204          AAKA   EXPSGNS1 ; Count iterations in top digits of A",
  "205          TFA    TAN",
  "206          BIE    ASINCOS1 ; branch if SIN/COS",
  "; Test ARCTAN termination",
  "207          CCK    DIGIT1 ; ARCTAN, compare C to K",
  "208          BINE   TRGLOOP2 ; loop if not done",
  "209          BIE    ARCDONE ; BET",
  "210 ASINCOS1 TFA    COS_TAN ; SIN/COS",
  "211          BINE   ACOSCHK ; branch if COS",
  "; Test ARCSIN termination",
  "212          CAB    MANT ; must be SIN",
  "213          BIE    TRGLOOP2",
  "214          BIE    ARCDONE ; Branch every time",
  "; Test ARCCOS termination",
  "215 ACOSCHK  CAK    MANT1 ; COS",
  "216          EXAB   MANT ; compare C-A the hard way",
  "217          CCB    MANT",
  "218          EXAB   MANT",
  "219          BIE    TRGLOOP2 ; C==A",
  "220 ARCDONE  SRLA   ALL ; shift iteration count into mantissa, divide by 1000",
  "221          SRLA   ALL",
  "222          SRLA   ALL",
  "223          SRLA   ALL",
  "224          SRLA   ALL",
  "225          BIE    NORMLIZE ; branch every time",
  "; SIN/COS/TAN loop done",
  "226 TRIGDONE TFA    TAN",
  "227          BIE    SINCOS",
  "228          ACKA   ALL ; doing TAN: A=C (denom)",
  "229          ABOC   ALL ; C=B (numer)",
  "230          AKB    ALL ; B=0",
  "231          ZFA    UP_LOW",
  "232          BIE    DODIV ; branch every time",
  "233 SINCOS   TFA    COS_TAN",
  "234          BIE    SIN ; branch for SIN",
  "235          ACKB   ALL ; COS: return C via B",
  "236 SIN      EXAB   ALL ; SIN: return B",
  "237          BIE    NORMLIZE ; BET (no overflow)",
  "238 LOGKEY   TFA    LOW ; low-MULT is antilog",
  "239          BIE    LOG",
  "; Antilog entry point.",
  "; The concept is to split the integer and fractional part of A. The integer",
  "; part becomes the EXP of the result. The antilog of the fractional part is ",
  "; computed using the equation 10^f = 10*.99^(229.15*(1-f))",
  "; ",
  "; First, split int and frac parts of A. Next LOGLOOP computes constant 229.15.",
  "; Control continues at ANTILOG which calls MULTMANT to multiply 1-frac by 229.15",
  "240 DOALOG   CAK    EXP1 ; Test exponent",
  "; Split int and frac parts of A: int in digits 1-4, frac in 7-10",
  "; Shortcut: If EXP > 0, assume EXP is 1. Anything bigger would probably overflow",
  "; This is totally wrong for cases like antilog(0.001E3)",
  "241          BINE   EXPZERO ; branch if exponent is 0",
  "242          CAK    EXP_S5; Test exponent sign",
  "243          BINE   EXPPOS4",
  "244          SRLA   MANT; Negative exponent: shift mantissa right to align",
  "245          SAKA   EXP1",
  "246          BIE    DOALOG ; Loop every time",
  "247 EXPPOS4  SLLA   MANT ; Positive EXP, assume it is 1",
  "248 EXPZERO  AKA    EXP ; Clear exponent",
  "249          SLLA   TOPSTUFF ; Shift integer part into digits 1-4 for later",
  "250          SLLA   TOPSTUFF",
  "; Compute log of A.",
  "; First compute -1/log(.99) = 229.15. Then compute -log(MANT A)/log(.99).",
  "; Divide the results to get log(MANT A). Finally, add EXP A to get the result.",
  "; Then compute -log(A)/go through power loop a second time",
  "251 LOG      AKC    ALL ; This entry point computes -1/log(.99) = 229.15",
  "252          ACKC   DIGIT1 ; C = 10.00000",
  "; LOGLOOP is used twice; once to compute the constant 229.15 and then again",
  "; on the actual argument.",
  "; Compute -log(C MANT) / log(.99).",
  "; Do this by repeatedly incrementing count until (C MANT)*.99^count is < 1",
  "; That yields count = -log(C) / log(.99) approximately",
  "; count is stored in C EXP, and the current C*.99 in C MANT",
  "253 LOGLOOP  ACKB   MANT ; Compute log B*.99^C until < .1",
  "254          SRLB   MANT",
  "255          SRLB   MANT",
  "256          SCBC   MANT ; C -= C / 100",
  "257          TFB    NEWEXP ; indicates ALOG here",
  "258          BINE   ALOGLOOP",
  "259          ACKC   EXPSGNS1 ; Count number of iterations",
  "260          CCK    MASKA1 ; C vs 100000",
  "261          BIE    LOGLOOP ; Loop if >=",
  "; Get a couple decimal points of accuracy by adding the remainder*100",
  "; Explanation using Taylor series:",
  "; .99^(epsilon*100) = 1-epsilon = 1/(1+epsilon) approximately",
  "; So if C*.99^N = 1+epsilon, then C*.99^(N+epsilon*100) = (1+epsilon)/(1+epsilon) = 1",
  "; Thus N + epsilon * 100 is the better approximation",
  "262          SCBB   EXPSGNS1 ; undo last iteration: count in B EXP",
  "263          ABCC   MANT ; undo last MANT subtract",
  "264          SCKC   MASKA1",
  "265          SRLB   ALL ; Shift count into B mantissa",
  "266          SRLB   ALL",
  "267          SRLB   ALL",
  "268          SRLB   ALL",
  "269          ABCB   MANT ; add epsilon*100",
  "270          EXAB   MANT ; result in A MANT",
  "271          TFA    LOW",
  "272          BINE   ANTILOG ; return to ANTILOG if LOW set",
  "273          ABOC   ALL ; Copy B (arg) to C",
  "274          FFA    TAN ; go through loop twice, tracked by TAN flag",
  "275          TFA    TAN",
  "276          BINE   LOGLOOP ; back to the loop with the argument",
  "; Second power loop done for LOG. A EXP is original EXP.",
  "; A MANT = -log(original A MANT) / log(.99)",
  "; B MANT = 229.15 = -1 / log(.99)",
  "; Copy A MANT to C MANT, then compute C MANT / B MANT",
  "; This yields A MANT = log(original A MANT)",
  "277          AAKC   MANT",
  "; For LOG fall-through: 229.15 in B, -log(arg)/log(.99) in A and C",
  "; At ALOGDIV entry: 1+epsilon in B, .99^N in C",
  "278 ALOGDIV  AKA    MANT ; clear A mant, arg exp still in A",
  "; Compute A MANT = C MANT / B MANT by long division",
  "279 DIVMANT  AKA    DIGIT4 ; start digit count at 4, iterate until 10",
  "; The DIVLOOP loop repeatedly subtracts B from C, counting into A",
  "280 DIVLOOP  CCB    MANT ; Compare C and B to see if subtraction done",
  "281          BINE   SHIFTDIV ; branch if C < B",
  "282          SCBC   MANT ; C -= B",
  "283          AAKA   MANT1 ; increment low digit of A",
  "284          BIE    DIVLOOP ; BET",
  "285 SHIFTDIV AAKC   DIGIT1 ; increment digit count into C",
  "286          BINE   DIVDONE ; overflow; done when count hits 10",
  "287          SLLA   MANT ; shift A mantissa left",
  "288          ACKA   DIGIT ; copy digit count back to A; clears flag",
  "289          SLLC   MANT ; and shift C mantissa left",
  "290          BIE    DIVLOOP ; branch every time",
  "291 DIVDONE  AKA    DIGIT; NOP to clear flag",
  "292          TFA    UP_LOW ; pick the return target",
  "293          BINE   ADDLOG ; continue for LOG",
  "294          BIE    NORMLIZE ; done for DIV",
  "295 WAITED   BIE    WAITED2 ; inconvenient WAITNO target",
  "; For LOG, add (original) A exponent to result via ADDSUB",
  "296 ADDLOG   AAKC   MANT ; A mantissa -> C",
  "297          AKA    MANT ; clear A mantissa",
  "298          SRLA   ALL ; shift exponent into top of mantissa (log of exponent)",
  "299          SRLA   ALL",
  "300          AKA    EXP ; clear exponent",
  "; At this point, original EXP is in A digits 5 and 6, log of original MANT is in C",
  "; Add them together to get final log",
  "301          BIE    ADDSUB ; BET (clear from AAKC)",
  "; A holds the original int part in digits 1-4, 229.15 in digits 6-10",
  "; B holds the original fractional part in digits 6-10",
  "302 ANTILOG  AAKC   MANT ; copy 229.15 to C",
  "303          AKA    MANT ; clear A MANT",
  "304          AKA    MASKA1",
  "305          SABA   MANT",
  "306          EXAB   MANT; B holds 1 - original fractional part",
  "307          BIE    MULTMANT ; Sub call to multiply by 229.15",
  "308 ALOGRET  SRLA   MANT",
  "309          SFB    NEWEXP; indicates ALOG",
  "310          BIE    LOG ; Branch every time",
  "; conditional for LOGLOOP when doing ANTILOG",
  "; loop number of times in A MANT",
  "311 ALOGLOOP SAKA   MANTD1 ; decrement A and if non-negative...",
  "312          BIE    LOGLOOP ; go back to LOGLOOP",
  "; Get a couple more digits of accuracy. The idea is that",
  "; .99^epsilon = 1-epsilon/100 = 1/(1+epsilon/100)) approximately",
  "; so divide by 1+remainder/100 to account for the fractional part of",
  "; the exponent in .99^N, since the loop only does the integer part.",
  "313          AAKA   MANTD1 ; restore A digits to 0",
  "314          SLLA   MANT ; use the ignored digits for extra accuracy?",
  "315          AAKA   MASKA1; A = 1 + remainder/100",
  "316          ABCC   MANT; restore value of C from extra iteration",
  "317          EXAB   MANT; B has correction factor, C has 10*.99^N",
  "318          ZFA    UP_LOW",
  "319          BINE   ALOGDIV ; BET divide and finish up ALOG",
  ";  ",
  "; A Flags:",
  "; 0 ALL - all flags, for clearing",
  "; 1 (S10) RET1FLAG - indicates return to DIV",
  "; 3 (S6) UP_LOW - indicates either UP or LOW functions",
  "; 5 (S0) LOW - indicates a LOW function",
  "; 7 (S9) TAN - indicates TAN selected",
  "; 11 (S5) COS_TAN - indicates COS or TAN selected",
  "; ",
  "; B Flags:",
  "; 0 ALL - all flags, for clearing",
  "; 1 (S10) EMODE - indicates E has been pressed",
  "; 6 (S8S7) OPDONE - indicates operation completed, waiting for number",
  "; 7 (S9) NEWEXP: E pressed, entering a new exponent; also for ALOG",
  ";  ",
  "; Masks:",
  ";  S value",
  "; a9876543210",
  "; 00000000000 mask 0 ALL - all digits",
  "; 5           mask 1 MANT_S5 - mantissa sign; 5 is negative",
  ";   00        mask 2 EXP - exponent for value",
  ";     1       mask 3 DIGIT1",
  ";     0000000 mask 4 MANT - mantissa",
  ";           1 mask 5 MANTLOW1 - low digit of mantissa",
  ";   01        mask 6 EXP1 - mantissa constant 1",
  ";  5          mask 7 EXP_S5 - exponent sign; 5 is negative",
  "; 000000      mask 8 TOPSTUFF",
  "; 0001        mask 9 EXPSGNS1 - exponent and signs, also a counter",
  ";     0000001 mask a MANT1 - mantissa constant 1",
  ";      1      mask b MASKA1 - counter or digit in mantissa",
  ";     00005   mask c MANTD5",
  ";     00001   mask d MANTD1",
  ";     4       mask e DIGIT4",
  ";     0       mask f DIGIT",
];
var objectCode = [
1408,1392,1792,1824,1860,1808,1360,1376,
518,1319,1360,1376,9,1360,1908,1072,
1083,1075,1121,1129,1073,1069,1051,1840,
1955,1840,516,1425,552,1430,33,1792,
1398,1631,1920,1683,34,2003,1540,4,
1399,1858,1872,1538,4,1329,1335,4,
1349,1347,4,1443,676,1431,57,1559,
4,1553,59,1443,677,1839,1632,2018,
65,2023,1719,72,1730,71,1840,1666,
1751,587,1840,1754,78,1840,1718,594,
1924,78,2017,1713,89,1540,130,1844,
1841,1652,597,130,1730,95,1849,1650,
114,1443,675,1355,1345,130,1409,1559,
105,1443,750,1839,1632,1844,2023,1719,
92,1538,1537,116,1451,1796,791,1908,
1781,637,1722,1540,120,1940,1786,119,
1445,820,1754,512,1747,145,1860,1751,
142,1686,141,1799,1798,1686,1558,132,
132,1908,1751,662,1686,1686,1558,152,
1441,614,1392,1334,1408,1750,161,1559,
159,1568,4,1351,1355,1686,681,1908,
165,1801,1689,1824,1445,180,1447,179,
1568,1819,185,1565,1820,1924,2011,1693,
738,1888,1888,1888,2012,1696,1936,1936,
1936,1872,1872,1872,2012,1584,1724,1920,
1920,1920,1445,183,1561,1447,210,1779,
697,220,1451,727,1732,185,220,1754,
1844,1764,1844,185,1904,1904,1904,1904,
1904,130,1447,233,1616,1600,1808,1411,
100,1451,236,1632,1840,130,1445,251,
1750,760,1751,759,1908,1686,240,1860,
1794,1864,1864,1824,2003,1636,1924,1924,
1700,1431,823,2009,1787,253,1993,2036,
1723,1920,1920,1920,1920,1588,1844,1445,
814,1600,1479,1447,765,1572,1796,1806,
1764,797,1700,1562,280,1571,803,1860,
1631,1892,280,1807,1443,808,130,10,
1572,1796,1904,1904,1794,61,1572,1796,
1803,1652,1844,117,1908,1335,251,1693,
253,1565,1860,1563,2036,1844,1411,790,
];
